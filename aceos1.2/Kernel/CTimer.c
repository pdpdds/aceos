/*              Timer Routines
                      Developed by Sam(samuelhard@yahoo.com) on 19-June-2002
                      
*/
#include "TypeDefs.h"
#include "MemMan.h"
#include "IO.h"
#include "Processor.h"
#include "DeviceDriver.h"

#define TMR_CONTROL 0x43
#define TMR_COUNTER0 0x40
#define TMR_COUNTER1 0x41
#define TMR_COUNTER2 0x42

BYTE Sys_TimerHardwareID;
BYTE TimerTickStatus;
void TimerHandler();

struct __TimerInfo
       {
       UINT16 Interval;         //
       UINT16 Count;
       BOOLEAN Enabled;
       void (*CallBackFn)();
       struct __TimerInfo * Next;
       };

struct __TimerInfo * __TimerQueue = NULL;
/* The __TimerQueue is a pointer to a __TimerInfo node in a linked list
   it always point to the next timer to execute.
   __TimerQueue is initialized by the InitializeTimer() function
*/
void TimerHand(UINT16 SubSystem,UINT32 Para1, UINT32 Para2)
	{struct __TimerInfo * tmpTimer=__TimerQueue;//finding the last node
	if ( tmpTimer == NULL ) // no timer ?
		return;
	while(tmpTimer)
		{if ( tmpTimer->Enabled )
			{tmpTimer->Count++;		//increase the count
			if ( tmpTimer->Count >= tmpTimer->Interval )// if interval reached call the function
				{tmpTimer->Count=0;
				tmpTimer->CallBackFn();
				}
			}
		tmpTimer=tmpTimer->Next;
		}
	}
BYTE InitTimer()
	{
	OutPortByte(TMR_CONTROL,0x36); // control register
	OutPortByte(TMR_COUNTER0,0xA9);// LSB of clock divisor
	OutPortByte(TMR_COUNTER0,0x4);// MSB of clock divisor

	OutPortByte(TMR_CONTROL,0x54);// control register
	OutPortByte(TMR_COUNTER1,18);// LSB only clock divisor

	TimerTickStatus=0; //disable hardware messages
	Sys_TimerHardwareID = RegisterDeviceDriver(0, 0, 0, "PC Timer Driver V1.0", "Power Team", TimerHand);
	if ( Sys_TimerHardwareID )
		SetIDT(32,TimerHandler);
	return Sys_TimerHardwareID;
	}
/* This function retunrs whether the timer will generate hardware messages or not*/
BYTE GetTimerTickStatus()
	{return TimerTickStatus;
	}
/* This function enables/disables the hardware messages generated by the timer*/
BYTE SetTimerTickStatus(BYTE Enabled)
	{TimerTickStatus=Enabled;
	}
UINT32 CreateTimer(UINT16 Interval, void (*CallBackFn)())
	{struct __TimerInfo * NewTimer=(struct __TimerInfo *) AllocHeap(sizeof(struct __TimerInfo));
	if ( NewTimer == NULL  ) //allocation failed
		return 0;

	NewTimer->Count=0;
	NewTimer->Interval=Interval;
	NewTimer->CallBackFn=CallBackFn-KERNEL_LOAD_ADDRESS;
	NewTimer->Enabled=1;		
	NewTimer->Next=NULL;

	if ( __TimerQueue == NULL ) //create root ?
		__TimerQueue=NewTimer;
	else
		{struct __TimerInfo * tmpTimer=__TimerQueue;//finding the last node
		while(tmpTimer->Next)
			tmpTimer=tmpTimer->Next;
		tmpTimer->Next = NewTimer;	//inserting new node
		}
	return NewTimer;
	}
void DropTimer(UINT32 TimerID)
	{//not implemented yet
	}
void ChangeTimerInfo(UINT32 TimerID, UINT16 Interval, void (*CallBackFn)(), BOOLEAN Enabled)
	{struct __TimerInfo * tmpTimer=__TimerQueue;//finding the last node
	while(tmpTimer)
		{if ( (UINT32)tmpTimer == TimerID )
			{tmpTimer->Interval=Interval;
			tmpTimer->CallBackFn=CallBackFn;
			tmpTimer->Enabled=Enabled;
			return;
			}
		tmpTimer=tmpTimer->Next;
		}
	}
